<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SimulationParameters vs OptionParameters Overview</title>
  <style>
    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: #222;
      margin: 2rem auto;
      max-width: 900px;
    }
    h1, h2 {
      color: #003366;
    }
    h3 {
      color: #004c99;
    }
    p {
      margin-bottom: 1rem;
    }
    code {
      background-color: #f4f4f4;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 0.95em;
    }
    .example {
      background-color: #f9f9f9;
      border-left: 4px solid #004c99;
      padding: 0.75rem 1rem;
      margin: 1rem 0;
    }
    ul {
      margin-left: 1.5rem;
    }
  </style>
</head>
<body>

  <h1>Understanding <code>SimulationParameters</code> and <code>OptionParameters</code></h1>
  <p>
    In earlier versions of the Monte Carlo Option Pricer, all configuration settings—such as
    strike price, volatility, path count, and option type—were bundled into a single parameters
    class. While functional, that structure tightly coupled two distinct ideas:
    the <strong>market and option definition</strong> itself and the <strong>simulation engine
    settings</strong> used to evaluate it. 
  </p>

  <p>
    The new design separates these concerns into two focused, reusable classes:
    <code>OptionParameters</code> and <code>SimulationParameters</code>. This modularization improves
    clarity, maintainability, and interoperability between the pricing engine and different option types.
  </p>

  <hr>

  <h2><code>OptionParameters</code>: Describing the Contract</h2>
  <p>
    The <code>OptionParameters</code> class represents the <em>financial contract</em> being priced.
    It contains the details that define what the option actually is—its payoff structure,
    strike level, and any special features such as barriers or averaging schemes.
  </p>

  <ul>
    <li><strong>Primary role:</strong> Encapsulates all <em>option-specific characteristics</em>.</li>
    <li><strong>Examples of fields:</strong> 
      <code>Strike</code>, <code>IsCall</code>, <code>AveragingType</code>,
      <code>BarrierLevel</code>, <code>LookbackType</code>.</li>
    <li><strong>Factory methods:</strong> Easy creation of standard option setups via
      <code>CreateEuropeanCall()</code>, <code>CreateBarrierOption()</code>, etc.</li>
    <li><strong>Does not simulate:</strong> This class only describes what is to be priced—it
      does not generate paths or perform calculations.</li>
  </ul>

  <div class="example">
    <strong>Example:</strong><br>
    <code>var opt = OptionParameters.CreateBarrierOption(100, 110, BarrierType.KnockOut, BarrierDirection.Up);</code>
  </div>

  <p>
    In this example, the <code>OptionParameters</code> object represents an <em>up-and-out barrier call</em>
    struck at 100 with a barrier at 110. It can be used interchangeably with any simulation configuration.
  </p>

  <hr>

  <h2><code>SimulationParameters</code>: Controlling the Engine</h2>
  <p>
    The <code>SimulationParameters</code> class describes the <em>numerical experiment</em> used to
    price the option. Instead of defining the contract, it configures how the Monte Carlo engine will
    simulate underlying price paths.
  </p>

  <ul>
    <li><strong>Primary role:</strong> Specifies all <em>model and numerical settings</em> for simulation.</li>
    <li><strong>Examples of fields:</strong>
      <code>InitialPrice</code>, <code>Volatility</code>, <code>RiskFreeRate</code>,
      <code>TimeToExpiry</code>, <code>TimeSteps</code>, <code>NumberOfPaths</code>,
      and <code>SimMode</code>.</li>
    <li><strong>Factory methods:</strong> Quickly create configurations for Antithetic,
      Control Variate, or Quasi-Random simulations.</li>
    <li><strong>Used by:</strong> <code>MonteCarloSimulator</code> and all option classes via
      <code>OptionBase</code>.</li>
  </ul>

  <div class="example">
    <strong>Example:</strong><br>
    <code>
      var sim = SimulationParameters.CreateControlVariate(10000, 252);<br>
      sim.InitialPrice = 100;<br>
      sim.Volatility = 0.25;<br>
      sim.RiskFreeRate = 0.03;<br>
      sim.TimeToExpiry = 1.0;
    </code>
  </div>

  <p>
    Here, <code>SimulationParameters</code> defines how the stochastic process is simulated—
    not what is being priced. It can be reused across many different option contracts.
  </p>

  <hr>

  <h2>How They Work Together</h2>
  <p>
    While these two classes serve different purposes, they complement each other in the pricing workflow.
    <code>OptionParameters</code> defines the <em>structure of the payoff</em>, while
    <code>SimulationParameters</code> defines the <em>dynamics of the underlying asset</em>.
  </p>

  <p>
    When an option is priced, the simulation engine uses the fields from
    <code>SimulationParameters</code> to generate thousands of possible price paths for the underlying
    asset. The resulting terminal prices or paths are then passed into payoff functions defined by
    the option type, which draw on information from <code>OptionParameters</code>.
  </p>

  <div class="example">
    <strong>Conceptual Flow:</strong>
    <pre>
SimulationParameters → defines how paths evolve (GBM, steps, variance reduction)
OptionParameters     → defines how payoffs are computed from those paths

MonteCarloSimulator.Simulate(SimulationParameters)
        ↓
OptionModel.BuildPayoffs(terminals, paths, OptionParameters)
        ↓
PricingResult (price, error, Greeks)
    </pre>
  </div>

  <p>
    By separating these concerns, the system gains flexibility: a single simulation configuration
    can be reused for multiple option types, and new payoff structures can be introduced without
    modifying the core simulation engine.
  </p>

  <hr>

  <h2>Summary</h2>
  <ul>
    <li><code>OptionParameters</code> → Defines <strong>what</strong> is priced (the contract).</li>
    <li><code>SimulationParameters</code> → Defines <strong>how</strong> it’s priced (the experiment).</li>
    <li>Together → They provide a clean interface between the <em>mathematical model</em>
        and the <em>financial instrument</em>, allowing the Monte Carlo pricer to remain modular,
        scalable, and extensible.</li>
  </ul>

</body>
</html>
